export const junk = `For array, object, function, and regular-expression values, it’s almost universally preferred that you use the literal form for creat‐ ing the values, but the literal form creates the same sort of object as the constructor form does (that is, there is no nonwrapped value).
Just as we’ve seen above with the other natives, these constructor forms should generally be avoided, unless you really know you need them, mostly because they introduce exceptions and gotchas that you probably don’t really want to deal with.
The Array constructor has a special form where if only one number argument is passed, instead of providing that value as contents of the array, it’s taken as a length to “presize the array” (well, sorta).
This is a terrible idea. Firstly, you can trip over that form acciden‐ tally, as it’s easy to forget.
As you can see with c in this example, empty slots in an array can happen after creation of the array. When changing the length of an array to go beyond its number of actually defined slot values, you implicitly introduce empty slots. In fact, you could even call delete b[1] in the above snippet, and it would introduce an empty slot into the middle of b.
Worse than that, at the time of writing, Firefox reports [ , , , ] for a and c. Did you catch why that’s so confusing? Look closely. Three commas implies four slots, not three slots like we’d expect.
What!? Firefox puts an extra , on the end of their serialization here because as of ES5, trailing commas in lists (array values, property lists, etc.) are allowed (and thus dropped and ignored). So if you were to type a [ , , , ] value into your program or the console, you’d actually get the underlying value that’s like [ , , ] (that is, an array with three empty slots). This choice, while confusing if reading the developer console, is defended as instead making copy-n-paste behavior accurate.
`